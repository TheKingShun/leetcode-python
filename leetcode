# leetcode-python
每天刷LeetCode~~~

001：-------------------------------------------------------------------------------------------------------------------
Given two strings s and t which consist of only lowercase letters.
String t is generated by random shuffling string s and then add one more letter at a random position.
Find the letter that was added in t.
//给定两个字符串s和t只包含小写字母。字符串t是由随机洗牌字符串s,然后再添加一个字母在一个随机位置。在t找到添加的字符。
>>>解决：
    class Solution:
        def findTheDifference(self, s, t):
            """
            :type s: str
            :type t: str
            :rtype: str
            """
            for t_each in t:
                if t_each not in s:
                    return t_each
                else:
                    if s.count(t_each)!=t.count(t_each):
                        return t_each
>>>重新洗牌排序只能保证元素的个数和原始相当的情况下次元素不属于新添加元素，若元素不存在于s字符中也表明此字符属于新添加字符;
>>>最优解：
def findTheDifference(self, s, t):
    """
    :type s: str
    :type t: str
    :rtype: str
    """
    ans = 0
    for c in s + t:
        ans ^= ord(c)
    return chr(ans)
>>>ord(x)函数是将x转换为相应的AscII码 是一个数字，chr（x）则将数字或16进制字符转换为字符串

002：---------------------------------------------------------------------------------------------------------------------
There is a list of sorted integers from 1 to n. Starting from left to right, remove the first number and every other number afterward until you reach the end of the list.

Repeat the previous step again, but this time from right to left, remove the right most number and every other number from the remaining numbers.

We keep repeating the steps again, alternating left to right and right to left, until a single number remains.

Find the last number that remains starting with a list of length n.
//有排序的列表从1到n的整数。从左到右,删除第一个数字和其他数量之后直到你到达列表的最后。重复前面的步骤,但这一次从右到左,删除数量最多,其他从剩下的数字。我们不断重复的步骤,交替从左到右和从右到左,直到一个数字仍然存在。找到最后一个数字仍然从一个长度为n的列表。

Input:
n = 9,
1 2 3 4 5 6 7 8 9
2 4 6 8
2 6
6

Output:
6

>>>class Solution:
    def lastRemaining(self, n):
        """
        :type n: int
        :rtype: int
        """
        num = list(range(1,n+1))
        while len(num) >1 :
            num = num[1::2][::-1]
        return num[0]
>>>利用序列的分片操作，将序列分割的结果返回给原序列，【：：-1】是将序列反转，当序列中的数字只有一项时即返回


003:====================================================================================================================
Given an array of integers, return indices of the two numbers such that they add up to a specific target.

You may assume that each input would have exactly one solution, and you may not use the same element twice.

Example:
Given nums = [2, 7, 11, 15], target = 9,

Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1].
给定一个整数数组,返回两个数的指数,他们加起来是一个具体的目标。你可能认为每个输入一个解决方案,你可能不会使用相同的元素两次。


>>> class Solution:
    def twoSum(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        """
        d={}
        for i , num in enumerate(nums):
            if num in d :
                return d[num],i
            d[target - num] = i
            
  定义一个空字典，里面存放的是{第二个加数数值：第一个加数下标} 如果num 在 字典d中的key序列中存在则证明可以存在

004：==================================================================================================================

You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.

You may assume the two numbers do not contain any leading zero, except the number 0 itself.

Input: (2 -> 4 -> 3) + (5 -> 6 -> 4)
Output: 7 -> 0 -> 8

>>>你有两个非空链表表示两个非负整数。数字存储在相反的顺序和每个节点包含一个数字。
添加两个数字并返回一个链表。你可能认为这两个数字不包含任何前导零,除了数字0本身。

>>># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def addTwoNumbers(self, l1, l2):
        """
        :type l1: ListNode
        :type l2: ListNode
        :rtype: ListNode
        """
        carry = 0
        root = n = ListNode(0)
        while l1 or l2 or carry:
            num1 = num2 = 0
            if l1 : 
                num1 = l1.val
                l1 = l1.next
            if l2 :
                num2 = l2.val
                l2 = l2.next
            carry , val = divmod(num1+num2+carry,10)
            n.next = ListNode(val)
            n= n.next
        return root.next


>>>这里主要是对链表的熟悉熟悉链表的next方法（https://leetcode.com/problems/add-two-numbers/solution/）

005：Given a string, find the length of the longest substring without repeating characters.

Examples:

Given "abcabcbb", the answer is "abc", which the length is 3.

Given "bbbbb", the answer is "b", with the length of 1.

Given "pwwkew", the answer is "wke", with the length of 3. Note that the answer must be a substring, "pwke" is a subsequence and not a substring.
　　给定一个字符串,查找最长的子串的长度没有重复字符。
　　鉴于“abcabcbb”,答案是“abc”,长度是3。
　　鉴于“bbbbb”,答案是“b”,与1的长度。
　　鉴于“pwwkew”,答案是“wke”,与3的长度。注意,答案必须是一个字符串,“pwke”子序列而不是子字符串。

>>>import heapq
class Solution:
    def lengthOfLongestSubstring(self, s):
        """
        :type s: str
        :rtype: int
        """
        target_list = []
        result_str = ""
        if s :
            for i in s:
                if i not in result_str :
                    result_str +=i  #将字符串添加
                else :
                    target_list.append(result_str)
                    for index in range(len(result_str)):
                       if result_str[index] == i :
                            result_str = str(result_str.split(i)[-1])+i
                            break
        target_list.append(result_str)
        return (len(max(target_list,key=lambda x:len(x))))

006:==================================================================================================================
There are two sorted arrays nums1 and nums2 of size m and n respectively.

Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).

Example 1:
nums1 = [1, 3]
nums2 = [2]

The median is 2.0
Example 2:
nums1 = [1, 2]
nums2 = [3, 4]

The median is (2 + 3)/2 = 2.5
　　有两个排序数组分别nums1和nums2大小m和n。
　　找到两个排序数组的值。整体运行时间复杂度应O(log(m + n))
　　示例1:
　　nums1 =[1,3]
　　nums2 =[2]
　　中位数是2.0
　　示例2:
　　nums1 =[1,2]
　　nums2 =(3、4)
　　中位数是(2 + 3)/ 2 = 2.5
  
  >>>class Solution:
    def findMedianSortedArrays(self, nums1, nums2):
        """
        :type nums1: List[int]
        :type nums2: List[int]
        :rtype: float
        """  
        if nums1 and nums2:
            nums1.extend(nums2)
            nums1.sort()
            return self.getResult(nums1)
        else:
            if nums1:
                 return self.getResult(nums1)
            else:
                 return self.getResult(nums2)

    def getResult(self,nums):
            length = len(nums)
            if length % 2 == 0:
                return ((nums[length//2]+nums[length//2-1])/2)
            else :
                if length > 1:
                    return (float(nums[length//2])) 
                else:return nums[0]
             
  >>>没啥好说的就是小学的中位数操作           
             
            
  
  
  
  
  
  
  
